# 快速入门

<cite>
**本文档中引用的文件**
- [README.md](file://README.md)
- [src/lib.rs](file://src/lib.rs)
- [src/fxmac.rs](file://src/fxmac.rs)
- [src/fxmac_dma.rs](file://src/fxmac_dma.rs)
- [src/fxmac_intr.rs](file://src/fxmac_intr.rs)
</cite>

## 目录
1. [构建环境要求](#构建环境要求)
2. [实现KernelFunc接口](#实现kernelfunc接口)
3. [驱动初始化](#驱动初始化)
4. [数据发送与接收](#数据发送与接收)
5. [常见陷阱](#常见陷阱)

## 构建环境要求

在使用fxmac_rs驱动之前，必须正确配置Rust交叉编译环境。该驱动专为aarch64架构设计，因此需要安装`aarch64-unknown-none-softfloat`目标。可以通过以下Cargo命令进行构建：

```bash
cargo build --target=aarch64-unknown-none-softfloat
```

此目标适用于没有操作系统支持的嵌入式环境（bare-metal），并使用软件浮点运算，确保在目标硬件PhytiumPi板上正确运行。

**Section sources**
- [README.md](file://README.md#L38-L40)

## 实现KernelFunc接口

`KernelFunc`是驱动与内核交互的核心接口，定义了五个必需实现的方法。这些方法为驱动提供了底层硬件访问能力。

### virt_to_phys 与 phys_to_virt
这两个方法负责虚拟地址与物理地址之间的相互转换。在嵌入式系统中，内存管理单元（MMU）会将虚拟地址映射到物理地址。`virt_to_phys`将内核分配的虚拟地址转换为DMA控制器可访问的物理地址；反之，`phys_to_virt`则执行逆向转换。正确的地址转换是确保DMA操作成功的基础。

### dma_alloc_coherent
此方法用于申请页对齐的连续DMA内存。它接收要分配的页数作为参数，并返回一个元组，包含CPU可访问的虚拟地址和DMA控制器使用的物理地址。该内存必须是“一致的”（coherent），意味着CPU缓存和设备看到的数据视图是一致的，通常通过禁用缓存或使用缓存维护操作来实现。

### dma_free_coherent
与`dma_alloc_coherent`配对，此方法用于释放先前分配的DMA内存页。它接收虚拟地址和页数作为参数，确保内存资源被正确回收，防止内存泄漏。

### dma_request_irq
此方法用于注册网卡中断处理程序。它接收中断号（IRQ）和一个回调函数作为参数。当网卡产生中断时（如收到数据包），系统会调用此回调函数。在提供的示例中，此方法未完全实现，仅打印警告日志，这可能导致无法处理接收中断，从而丢失数据包。

**Section sources**
- [src/lib.rs](file://src/lib.rs#L42-L57)
- [README.md](file://README.md#L13-L35)

## 驱动初始化

驱动的初始化通过调用`xmac_init`函数完成。该函数接受一个MAC地址作为输入参数，并返回一个指向静态可变`FXmac`实例的引用。

首先，用户需要定义一个实现了`KernelFunc` trait的结构体（如`FXmacDriver`）。然后，创建一个包含目标MAC地址的数组。最后，调用`xmac_init`函数，传入MAC地址，即可获得一个已初始化的`FXmac`设备实例。这个实例是后续所有网络操作的基础。

```rust
let hwaddr: [u8; 6] = [0x55, 0x44, 0x33, 0x22, 11, 0x00];
let fxmac_device: &'static mut FXmac = fxmac_rs::fxmac::xmac_init(&hwaddr);
```

`xmac_init`函数内部会执行一系列复杂的初始化步骤，包括重置硬件、配置PHY、初始化DMA引擎和设置中断等，最终启动MAC控制器。

**Section sources**
- [src/fxmac.rs](file://src/fxmac.rs#L190-L300)
- [README.md](file://README.md#L28-L32)

## 数据发送与接收

### 发送数据包
数据发送通过`FXmacLwipPortTx`函数完成。该函数接收一个`FXmac`设备实例和一个`Vec<Vec<u8>>`类型的待发送数据包列表。每个内部的`Vec<u8>`代表一个独立的以太网帧。

```rust
let mut tx_vec = Vec::new();
tx_vec.push(packet.to_vec());
FXmacLwipPortTx(fxmac_device, tx_vec);
```

在底层，`FXmacSgsend`函数会将数据复制到预先分配的DMA缓冲区，更新传输描述符环（BD ring），并触发DMA传输。

### 接收数据包
数据接收通过`FXmacRecvHandler`函数轮询完成。该函数接收一个`FXmac`设备实例，并返回一个`Option<Vec<Vec<u8>>>`，其中包含接收到的所有数据包。

```rust
let recv_packets = FXmacRecvHandler(fxmac_device);
```

该函数会检查接收描述符环，找出已被硬件填充的描述符，从对应的DMA缓冲区中读取数据，将其复制到新的`Vec<u8>`中，并将这些数据包打包成一个列表返回。如果没有任何数据包到达，则返回`None`。

**Section sources**
- [src/fxmac_dma.rs](file://src/fxmac_dma.rs#L757-L876)
- [README.md](file://README.md#L33-L37)

## 常见陷阱

在使用此驱动时，需注意以下常见问题：
- **DMA内存对齐**：分配的DMA内存必须满足特定的对齐要求（如128字节对齐）。不正确的对齐可能导致DMA传输失败或系统不稳定。
- **中断未注册**：如示例所示，`dma_request_irq`方法未实现。这会导致接收中断无法被处理，从而使`FXmacRecvHandler`无法及时获取新数据包，造成接收性能下降甚至数据丢失。务必在生产环境中正确实现中断注册。
- **缓存一致性**：在DMA操作前后，必须执行适当的缓存维护操作（如刷新或无效化），以确保CPU和DMA设备之间数据的一致性。

**Section sources**
- [src/fxmac_dma.rs](file://src/fxmac_dma.rs#L110-L115)
- [src/fxmac_intr.rs](file://src/fxmac_intr.rs#L380-L383)
- [README.md](file://README.md#L18-L20)