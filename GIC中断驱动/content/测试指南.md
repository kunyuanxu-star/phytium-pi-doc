# 测试指南

<cite>
**本文档引用的文件**
- [test.sh](file://test.sh)
- [test_v3.sh](file://test_v3.sh)
- [itest/test-base/src/lib.rs](file://itest/test-base/src/lib.rs)
- [itest/test-base/src/test_suit/mod.rs](file://itest/test-base/src/test_suit/mod.rs)
- [itest/test-base/src/test_suit/ppi.rs](file://itest/test-base/src/test_suit/ppi.rs)
- [itest/test-base/src/test_suit/sgi.rs](file://itest/test-base/src/test_suit/sgi.rs)
- [itest/test-base/src/lang_items.rs](file://itest/test-base/src/lang_items.rs)
- [itest/test-base/src/logger.rs](file://itest/test-base/src/logger.rs)
- [itest/test-base/src/mem.rs](file://itest/test-base/src/mem.rs)
- [itest/test-gicv2/src/lib.rs](file://itest/test-gicv2/src/lib.rs)
- [itest/test-gicv3/src/lib.rs](file://itest/test-gicv3/src/lib.rs)
- [itest/test-base/Cargo.toml](file://itest/test-base/Cargo.toml)
- [itest/test-gicv2/Cargo.toml](file://itest/test-gicv2/Cargo.toml)
- [itest/test-gicv3/Cargo.toml](file://itest/test-gicv3/Cargo.toml)
</cite>

## 目录
1. [简介](#简介)
2. [测试套件结构](#测试套件结构)
3. [运行测试](#运行测试)
4. [测试用例编写](#测试用例编写)
5. [为新功能添加测试](#为新功能添加测试)
6. [测试覆盖率与持续集成](#测试覆盖率与持续集成)
7. [贡献者建议](#贡献者建议)

## 简介
本指南旨在为开发者提供关于如何运行和理解 `arm-gic-driver` 项目中集成测试（`itest`）的全面指导。该测试套件专为在 `no_std` 环境下验证 ARM GIC（通用中断控制器）驱动程序的功能而设计，覆盖 GICv2 和 GICv3 架构。本文将详细介绍测试目录结构、执行脚本、测试用例的实现方式以及如何为新功能贡献测试代码。

## 测试套件结构

`itest` 目录是整个测试体系的核心，其结构清晰地分离了通用测试基础与特定版本的测试模块。

- `test-base`：提供所有测试共享的基础组件，包括内存初始化、日志记录、中断处理接口抽象等。
- `test-gicv2`：针对 GICv2 架构的测试入口，依赖 `test-base` 并实现具体的 GICv2 初始化逻辑。
- `test-gicv3`：针对 GICv3 架构的测试入口，结构与 `test-gicv2` 类似，但使用 GICv3 的初始化流程。

`test-base` 中的关键模块包括：
- `test_suit`：定义了 `TestIf` trait 和具体的测试用例（如 `ppi.rs` 和 `sgi.rs`）。
- `lang_items.rs`：提供了 `no_std` 环境所必需的语言项，如 `panic_handler`。
- `logger.rs`：实现了简单的日志记录器，将日志输出到控制台。
- `mem.rs`：负责堆内存的初始化和管理。

**Section sources**
- [itest/test-base/src/lib.rs](file://itest/test-base/src/lib.rs)
- [itest/test-base/src/lang_items.rs](file://itest/test-base/src/lang_items.rs)
- [itest/test-base/src/logger.rs](file://itest/test-base/src/logger.rs)
- [itest/test-base/src/mem.rs](file://itest/test-base/src/mem.rs)

## 运行测试

项目提供了两个 shell 脚本来简化测试的执行过程。

### 使用 `test.sh` 运行 GICv2 测试
`test.sh` 脚本用于在 `aarch64-unknown-none-softfloat` 目标上编译并运行 `test-gicv2` 包的测试。

```bash
./test.sh
```

该脚本内部执行的命令为：
```bash
cargo test --target aarch64-unknown-none-softfloat -p test-gicv2 --test test -- --show-output
```

### 使用 `test_v3.sh` 运行 GICv3 测试
`test_v3.sh` 脚本功能与 `test.sh` 相同，但针对的是 `test-gicv3` 包。

```bash
./test_v3.sh
```

其内部命令为：
```bash
cargo test --target aarch64-unknown-none-softfloat -p test-gicv3 --test test -- --show-output
```

这两个脚本都使用 `--test test` 来运行 `tests` 目录下的 `test.rs` 文件，并通过 `-- --show-output` 确保测试过程中的日志输出能够被显示。

**Section sources**
- [test.sh](file://test.sh)
- [test_v3.sh](file://test_v3.sh)

## 测试用例编写

测试用例位于 `test-base/src/test_suit/` 目录下，通过实现具体的函数来验证驱动程序的功能。

### PPI 中断测试
`ppi.rs` 文件中的 `test_irq` 函数负责测试私有外设中断（PPI）。它通过配置 ARM 通用定时器来触发一个 PPI 中断（ID 14），然后等待中断处理函数被调用。测试过程包括：
1.  设置中断优先级并启用中断。
2.  配置通用定时器，在 1ms 后触发中断。
3.  进入一个循环，等待全局标志 `TIMER_INTERRUPT_FIRED` 被设置。
4.  如果在 2ms 内未收到中断，则测试失败。
5.  清理定时器和中断配置。

中断处理函数 `handle` 会在中断触发时被调用，它负责设置标志位以通知主测试循环。

### SGI 中断测试
`sgi.rs` 文件中的 `test_to_current_cpu` 函数用于测试软件生成的中断（SGI）。它通过调用 `sgi_to_current` 方法向当前 CPU 发送一个 SGI（ID 1），然后等待中断被处理。测试逻辑与 PPI 测试类似，包括配置、发送、等待和超时检查。

`handle` 函数会验证中断的来源 CPU 是否与预期一致。

**Section sources**
- [itest/test-base/src/test_suit/ppi.rs](file://itest/test-base/src/test_suit/ppi.rs)
- [itest/test-base/src/test_suit/sgi.rs](file://itest/test-base/src/test_suit/sgi.rs)
- [itest/test-base/src/test_suit/mod.rs](file://itest/test-base/src/test_suit/mod.rs)

## 为新功能添加测试

当为 `arm-gic-driver` 添加新功能时，应遵循以下步骤来编写相应的测试。

### 实现 `TestIf` 接口
`test-base` 通过 `TestIf` trait 提供了一个抽象接口，用于与具体的 GIC 实例进行交互。`test-gicv2` 和 `test-gicv3` 分别实现了该接口的 `CpuImpl` 结构体。新功能的测试应通过此接口进行，以确保测试代码的可重用性。

### 编写新的测试函数
在 `test_suit` 模块中创建新的 `.rs` 文件或在现有文件中添加新的测试函数。函数应遵循以下模式：
1.  使用 `log` 宏记录测试进度。
2.  通过 `test_if()` 获取 `TestIf` 实例来配置和控制中断。
3.  设置一个全局原子变量作为中断触发的标志。
4.  执行触发中断的操作。
5.  在一个循环中等待标志被设置，同时实现超时机制。
6.  清理资源并断言测试结果。

### 确保 `no_std` 兼容性
所有测试代码都必须在 `no_std` 环境下运行。这意味着不能使用标准库（`std`），而应依赖 `core`、`alloc` 等子集。`test-base` 已通过 `#![no_std]` 属性和 `buddy_system_allocator` 提供了必要的支持。

**Section sources**
- [itest/test-gicv2/src/lib.rs](file://itest/test-gicv2/src/lib.rs)
- [itest/test-gicv3/src/lib.rs](file://itest/test-gicv3/src/lib.rs)
- [itest/test-base/src/test_suit/mod.rs](file://itest/test-base/src/test_suit/mod.rs)

## 测试覆盖率与持续集成

虽然当前代码库中未明确指定测试覆盖率目标，但现有的测试套件已经覆盖了 GIC 驱动的核心功能，包括中断的启用、禁用、优先级设置以及 PPI 和 SGI 的处理流程。

持续集成（CI）流程应配置为在每次提交时自动执行 `test.sh` 和 `test_v3.sh` 脚本，以确保对 GICv2 和 GICv3 的支持始终保持有效。CI 环境需要提供一个能够运行 `aarch64-unknown-none-softfloat` 目标代码的模拟器或硬件平台。

**Section sources**
- [test.sh](file://test.sh)
- [test_v3.sh](file://test_v3.sh)

## 贡献者建议

对于希望为 `arm-gic-driver` 贡献代码的开发者，以下是一些实用的建议：

1.  **运行现有测试**：在进行任何更改之前，首先确保 `./test.sh` 和 `./test_v3.sh` 能够在您的开发环境中成功运行。
2.  **遵循测试模式**：编写新测试时，参考 `ppi.rs` 和 `sgi.rs` 中的现有模式，保持代码风格和结构的一致性。
3.  **关注 `no_std` 限制**：避免在测试代码中使用任何 `std` 特定的功能。
4.  **利用日志进行调试**：在测试函数中大量使用 `info!` 和 `debug!` 宏，这有助于在 CI 或本地调试时快速定位问题。
5.  **提交前验证**：在提交 Pull Request 之前，务必在本地完整运行所有测试，以确保您的更改不会破坏现有功能。