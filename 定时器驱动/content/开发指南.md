# 开发指南

<cite>
**本文档引用的文件**
- [lib.rs](file://src/lib.rs)
- [Cargo.toml](file://Cargo.toml)
</cite>

## 目录
1. [引言](#引言)
2. [项目结构与依赖](#项目结构与依赖)
3. [寄存器块结构体定义](#寄存器块结构体定义)
4. [驱动实例化与共享状态管理](#驱动实例化与共享状态管理)
5. [中断处理程序框架](#中断处理程序框架)
6. [RPM计算逻辑实现](#rpm计算逻辑实现)
7. [测试策略建议](#测试策略建议)
8. [调试技巧与注意事项](#调试技巧与注意事项)

## 引言

本开发指南旨在为贡献者提供一份详尽的实践指导，帮助从零开始实现飞腾派平台的转速监控（Tachometer）驱动功能。文档将围绕 `lib.rs` 文件展开，详细介绍如何在 `no_std` 环境下构建一个高效、安全的嵌入式驱动程序。内容涵盖寄存器操作、并发控制、中断处理、数据采样与计算等核心环节。

## 项目结构与依赖

当前项目遵循标准的 Rust 库结构，包含一个源代码目录 `src/` 和一个配置文件 `Cargo.toml`。主模块文件为 `src/lib.rs`，已正确声明 `#![no_std]` 属性以适应无操作系统环境。

**Section sources**
- [Cargo.toml](file://Cargo.toml#L1-L15)

### 核心依赖说明

`Cargo.toml` 中列出了驱动实现所必需的核心依赖：
- **tock-registers**: 用于安全地定义和访问硬件寄存器，支持字段屏蔽与读写权限控制。
- **log**: 提供日志输出功能，便于调试和运行时状态追踪。
- **spin**: 提供 `spin::Mutex` 和 `spin::Once`，适用于 `no_std` 环境下的同步原语，是实现共享状态和一次性初始化的关键。

这些依赖项均已禁用默认功能，并仅启用了必要的特性，确保了最小化依赖和内存占用。

**Section sources**
- [Cargo.toml](file://Cargo.toml#L10-L14)

## 寄存器块结构体定义

尽管当前 `lib.rs` 文件中尚未实现具体代码，但根据驱动开发的最佳实践，应在其中定义代表硬件寄存器布局的结构体。这需要利用 `tock-registers` 宏来创建类型安全的寄存器接口。

应使用 `register_bitfields!` 和 `register_structs!` 宏来定义寄存器的位字段和整体结构。通过这种方式，可以精确控制每个字段的读写权限（如只读、只写、读写），并自动处理字段屏蔽，避免对保留位的意外修改。

例如，一个典型的寄存器块可能包含控制寄存器、状态寄存器和数据计数寄存器。每个寄存器都应被映射到特定的内存地址偏移量。

**Section sources**
- [lib.rs](file://src/lib.rs#L1-L3)

## 驱动实例化与共享状态管理

在 `no_std` 环境中，全局可变状态的管理至关重要。推荐使用 `spin::Once<T>` 结合 `lazy_static` 模式来完成驱动实例的一次性初始化。

### 共享状态设计

驱动的核心状态，如脉冲计数器和时间戳，需要在中断处理程序和主循环之间共享。为此，应使用 `Arc<Mutex<>>` 或更轻量级的 `spin::Mutex<Guard>` 来包装这些状态。由于 `Arc` 在 `no_std` 下可能不可用或过于重量，直接使用静态分配的 `spin::Mutex` 是更常见的选择。

```rust
static TACHOMETER: spin::Once<Mutex<Tachometer>> = spin::Once::new();
```

初始化函数（如 `init`）负责在系统启动时调用 `spin::Once::call_once` 来设置硬件并初始化全局实例。此过程必须保证线程安全且仅执行一次。

**Section sources**
- [lib.rs](file://src/lib.rs#L1-L3)

## 中断处理程序框架

脉冲计数通常由外部中断触发。中断处理程序的基本框架应包括以下步骤：

1.  **获取锁**：进入中断后，立即尝试获取保护共享状态的 `spin::Mutex`。
2.  **原子操作**：在持有锁的上下文中，对脉冲计数器进行原子递增，并记录当前的时间戳（可选，用于计算瞬时速度）。
3.  **释放锁与退出**：完成操作后释放锁，并清除中断标志位。

**重要提示**：由于 `spin::Mutex` 在中断禁用场景下可能导致死锁（自旋等待会阻塞更高优先级的中断），因此必须确保中断处理程序的执行时间极短，并仔细评估锁的竞争情况。在某些情况下，可能需要使用更高级的同步机制或避免在中断中持有锁。

**Section sources**
- [lib.rs](file://src/lib.rs#L1-L3)

## RPM计算逻辑实现

RPM（每分钟转数）的计算依赖于周期性的采样。系统定时器应定期触发一个任务（可能在主循环中），该任务执行以下操作：

1.  **获取快照**：在临界区内读取当前的脉冲计数值，并立即重置计数器。
2.  **应用公式**：使用以下公式计算RPM：
    ```
    RPM = (pulse_count / pulses_per_revolution) * (60 / sample_interval_seconds)
    ```
    其中：
    - `pulse_count` 是本次采样周期内累积的脉冲数。
    - `pulses_per_revolution` 是传感器每转产生的脉冲数（一个常量，取决于硬件）。
    - `sample_interval_seconds` 是两次采样之间的时间间隔（以秒为单位）。

这个计算结果可以用于更新内部状态、触发回调或通过日志输出。

**Section sources**
- [lib.rs](file://src/lib.rs#L1-L3)

## 测试策略建议

尽管当前项目尚无测试模块，但应预先规划测试结构。

### 单元测试 (`#[cfg(test)]`)
应在 `lib.rs` 内部或单独的 `tests/` 目录下组织单元测试。这些测试可以模拟寄存器行为，验证RPM计算公式的正确性，以及检查状态机的转换逻辑。

### 集成测试 (`tests/` 目录)
集成测试应放在项目根目录下的 `tests/` 目录中。它们可以链接真实的驱动库，并在目标硬件或仿真环境中运行，以验证中断处理、定时采样和硬件交互的整体流程。

**Section sources**
- [lib.rs](file://src/lib.rs#L1-L3)

## 调试技巧与注意事项

### 日志输出
充分利用 `log` crate 输出关键信息。例如，在中断处理程序中记录“Pulse received”，在每次RPM计算后输出“Current RPM: X”。这有助于在开发和故障排查时理解程序的执行流。

### 死锁风险警示
再次强调，`spin::Mutex` 在中断处理程序中的使用存在固有的死锁风险。如果中断A持有了锁，而中断B（具有更高优先级）被触发并尝试获取同一个锁，中断B将永远自旋，导致系统挂起。务必在文档和代码注释中明确提醒开发者注意此风险，并考虑替代方案，如使用无锁队列或仅在中断中设置标志位，而在主循环中处理实际的数据更新。

**Section sources**
- [lib.rs](file://src/lib.rs#L1-L3)