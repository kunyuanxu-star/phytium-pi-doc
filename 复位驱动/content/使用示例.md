<cite>
**本文档中引用的文件**   
- [lib.rs](file://src/lib.rs)
</cite>

# 使用示例

## 目录
1. [完整初始化与系统复位流程](#完整初始化与系统复位流程)
2. [外设管理示例](#外设管理示例)
3. [状态监控：非阻塞轮询模式](#状态监控非阻塞轮询模式)
4. [错误处理最佳实践](#错误处理最佳实践)
5. [宏 with_cru 的直接使用](#宏-with_cru-的直接使用)

## 完整初始化与系统复位流程

本示例展示如何在嵌入式环境中正确初始化CRU控制器并执行系统复位。首先通过`init_cru`函数设置基地址为0x2800_0000，然后调用`system_reset()`函数触发系统级复位，并检查返回结果以确认操作成功。

该流程体现了资源受限环境下驱动初始化的标准模式，包含必要的安全检查和日志记录机制。

```rust
use phytium_pi_cru::{init_cru, system_reset, CruConfig};

fn main() {
    // 配置CRU实例，指定基地址
    let config = CruConfig {
        instance_id: 0,
        base_address: 0x2800_0000usize,
    };

    // 初始化CRU控制器
    match init_cru(config) {
        Ok(()) => {
            log::info!("CRU初始化成功");
            // 执行系统复位
            if system_reset().unwrap_or(false) {
                log::info!("系统复位成功触发");
            } else {
                log::error!("系统复位超时");
            }
        }
        Err(e) => log::error!("CRU初始化失败: {}", e),
    }
}
```

**Section sources**
- [lib.rs](file://src/lib.rs#L179-L206)
- [lib.rs](file://src/lib.rs#L245-L251)

## 外设管理示例

此示例演示如何使用`reset_peripherals`函数批量复位多个GPIO外设（GPIO0和GPIO5）。通过传入包含外设ID的数组，实现高效的批量操作，减少重复代码并提高执行效率。

该模式适用于需要同时重置多个相关外设的场景，如系统启动时的硬件初始化阶段。

```rust
use phytium_pi_cru::{init_cru, reset_peripherals, PeripheralId, CruConfig};

fn main() {
    // 初始化CRU
    let config = CruConfig {
        instance_id: 0,
        base_address: 0x2800_0000usize,
    };
    let _ = init_cru(config);

    // 定义要复位的外设列表
    let peripherals = &[PeripheralId::Gpio0, PeripheralId::Gpio5];

    // 批量复位外设
    match reset_peripherals(peripherals) {
        Ok(success) => {
            if success {
                log::info!("GPIO0 和 GPIO5 复位成功");
            } else {
                log::error!("外设复位超时");
            }
        }
        Err(e) => log::error!("复位操作失败: {}", e),
    }
}
```

**Section sources**
- [lib.rs](file://src/lib.rs#L179-L206)
- [lib.rs](file://src/lib.rs#L257-L263)

## 状态监控：非阻塞轮询模式

本示例模拟对复位完成状态的持续监控，采用非阻塞轮询方式反复调用`is_reset_done`函数直至返回true。这种设计避免了长时间阻塞主线程，允许系统在等待期间处理其他任务或进行超时管理。

该模式特别适合实时性要求较高的嵌入式应用，确保系统响应性和可靠性。

```rust
use phytium_pi_cru::{init_cru, is_reset_done, CruConfig};
use core::hint::spin_loop;

fn main() {
    let config = CruConfig {
        instance_id: 0,
        base_address: 0x2800_0000usize,
    };
    let _ = init_cru(config);

    // 循环检测复位状态
    loop {
        match is_reset_done() {
            Ok(done) => {
                if done {
                    log::info!("复位已完成");
                    break;
                }
                // 短暂延时后继续轮询
                for _ in 0..100 {
                    spin_loop();
                }
            }
            Err(e) => {
                log::error!("状态查询失败: {}", e);
                break;
            }
        }
    }
}
```

**Section sources**
- [lib.rs](file://src/lib.rs#L179-L206)
- [lib.rs](file://src/lib.rs#L269-L275)

## 错误处理最佳实践

该示例重点展示如何正确捕获和处理`init_cru`函数可能抛出的重复初始化错误。通过模式匹配精确识别错误类型，并执行相应的日志记录和恢复策略，体现了健壮的错误处理机制。

在无标准库支持的嵌入式环境中，完善的错误处理是保证系统稳定运行的关键。

```rust
use phytium_pi_cru::{init_cru, CruConfig};

fn main() {
    let config = CruConfig {
        instance_id: 0,
        base_address: 0x2800_0000usize,
    };

    // 第一次初始化
    match init_cru(config.clone()) {
        Ok(()) => log::info!("首次初始化成功"),
        Err(e) => log::error!("初始化失败: {}", e),
    }

    // 尝试重复初始化 - 应捕获错误
    match init_cru(config) {
        Ok(()) => log::warn!("意外：重复初始化成功"),
        Err("CRU already initialized") => {
            log::info!("正确捕获重复初始化错误");
            // 正常情况下的预期行为
        }
        Err(e) => log::error!("未知错误: {}", e),
    }
}
```

**Section sources**
- [lib.rs](file://src/lib.rs#L179-L206)

## 宏 with_cru 的直接使用

本示例鼓励开发者直接使用`with_cru`宏来执行底层CRU操作，从而获得更精细的控制能力。通过闭包形式传递操作逻辑，既能保证资源的安全访问，又能灵活定制具体行为。

这种方式加深了对CRU内部工作机制的理解，适用于需要高级定制或调试的场景。

```rust
use phytium_pi_cru::{with_cru, CruController};

fn main() {
    // 直接使用with_cru宏执行自定义操作
    let result = with_cru!(|mut controller: CruController| {
        // 在此处可直接调用CruController的方法
        controller.system_reset()
    });

    match result {
        Ok(success) => {
            if success {
                log::info!("通过with_cru宏成功执行系统复位");
            } else {
                log::error!("复位操作超时");
            }
        }
        Err(e) => log::error!("CRU操作失败: {}", e),
    }
}
```

**Section sources**
- [lib.rs](file://src/lib.rs#L208-L243)