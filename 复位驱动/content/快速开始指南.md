# 快速开始指南

<cite>
**Referenced Files in This Document **  
- [Cargo.toml](file://Cargo.toml)
- [src/lib.rs](file://src/lib.rs#L1-L285)
</cite>

## 目录
1. [简介](#简介)
2. [项目集成](#项目集成)
3. [初始化配置](#初始化配置)
4. [API 使用示例](#api-使用示例)
5. [lookup_config 函数详解](#lookup_config-函数详解)
6. [安全边界说明](#安全边界说明)
7. [常见问题排查](#常见问题排查)
8. [最小可运行代码](#最小可运行代码)

## 简介
`phytium-pi-cru` 是一个专为 Phytium Pi 平台设计的时钟与复位单元（CRU）驱动库，适用于 Rust 的 `no-std` 环境。本指南将详细介绍如何在您的嵌入式项目中集成和使用此驱动，涵盖从依赖添加到功能调用的完整流程。

## 项目集成

### 添加依赖到 Cargo.toml
要将 `phytium-pi-cru` 驱动集成到您的 Rust no-std 项目中，首先需要在项目的 `Cargo.toml` 文件中添加该依赖项。

```toml
[dependencies]
phytium-pi-cru = { path = "/path/to/phytium-pi-cru" }
```

如果通过 Git 仓库引用：

```toml
[dependencies.phytium-pi-cru]
git = "https://github.com/arceos-org/phytium-pi-cru"
rev = "main"
```

### 特性配置 (Features)
当前版本的 `phytium-pi-cru` 库未定义任何可选特性（features），因此无需进行额外的特性配置。其默认依赖包括：
- `tock-registers`: 用于寄存器操作
- `log`: 用于日志输出
- `spin`: 用于无锁同步原语

这些依赖均以 `default-features = false` 构建，确保了对 `no-std` 环境的良好支持。

### 目标平台兼容性
该驱动设计用于裸机（bare-metal）环境，不依赖于标准库（`#![no_std]`）。它直接操作物理内存地址来访问 CRU 寄存器，因此必须确保目标平台的内存映射与驱动预期的基地址相匹配。目前，驱动内部硬编码的基地址为 `0x2800_0000`，适用于特定的 Phytium Pi 硬件配置。

**Section sources**
- [Cargo.toml](file://Cargo.toml#L1-L41)
- [src/lib.rs](file://src/lib.rs#L1-L285)

## 初始化配置

### 调用 init_cru 函数
在使用任何 CRU 功能之前，必须先调用 `init_cru` 函数进行初始化。此函数接收一个 `CruConfig` 结构体作为参数，该结构体包含实例 ID 和 CRU 寄存器的基地址。

#### 参数说明
- **base_address**: 指向 CRU 寄存器块起始位置的物理内存地址。
- **instance_id**: 当前 CRU 实例的标识符。根据源码，目前仅支持 `instance_id = 0`。

#### 示例代码
```rust
use phytium_pi_cru::{init_cru, CruConfig};

// 定义 CRU 配置
let config = CruConfig {
    instance_id: 0,
    base_address: 0x2800_0000usize, // 根据实际硬件调整
};

// 初始化 CRU 控制器
match init_cru(config) {
    Ok(()) => println!("CRU 初始化成功"),
    Err(e) => println!("CRU 初始化失败: {}", e),
}
```

**Section sources**
- [src/lib.rs](file://src/lib.rs#L167-L215)

## API 使用示例

### 执行系统复位
通过 `api` 模块提供的 `system_reset()` 函数可以触发整个系统的复位。

```rust
use phytium_pi_cru::api;

// 尝试执行系统复位
match api::system_reset() {
    Ok(success) => {
        if success {
            println!("系统复位指令已发出");
        } else {
            println!("系统复位超时");
        }
    },
    Err(e) => println!("无法执行复位: {}", e),
}
```

### 复位外设
`reset_peripheral` 函数允许您复位指定的单个外设。例如，复位 GPIO0 外设：

```rust
use phytium_pi_cru::{api, PeripheralId};

// 复位 GPIO0 外设
match api::reset_peripheral(PeripheralId::Gpio0) {
    Ok(success) => {
        if success {
            println!("GPIO0 复位完成");
        } else {
            println!("GPIO0 复位超时");
        }
    },
    Err(e) => println!("无法复位 GPIO0: {}", e),
}
```

您也可以使用 `reset_peripherals` 函数批量复位多个外设。

**Section sources**
- [src/lib.rs](file://src/lib.rs#L217-L270)
- [src/lib.rs](file://src/lib.rs#L63-L112)

## lookup_config 函数详解

### 作用
`lookup_config` 函数提供了一种便捷的方式来查询预定义的 CRU 配置。它根据传入的 `instance_id` 返回对应的 `CruConfig`。

### 返回值含义
- **返回 `Some(CruConfig)`**: 表示找到了有效的配置。目前，只有当 `instance_id` 为 `0` 时才会返回配置，其 `base_address` 固定为 `0x2800_0000`。
- **返回 `None`**: 表示请求的实例 ID 无效或不受支持。根据当前实现，任何大于等于 `1` 的 `instance_id` 都会返回 `None`。

此函数可用于动态获取配置信息，但在此版本中其用途较为有限，因为配置是硬编码的。

**Section sources**
- [src/lib.rs](file://src/lib.rs#L217-L270)

## 安全边界说明

### unsafe 代码的安全要求
驱动中的 `CruController::new` 方法被标记为 `unsafe`，因为它涉及原始指针的解引用。调用者必须严格遵守以下安全契约：

1. **有效的物理地址**: 提供的 `base_address` 必须指向物理上存在的、可访问的 CRU 寄存器内存区域。
2. **正确的内存映射**: 该地址必须已在内存管理单元（MMU）或页表中正确映射，以便 CPU 可以安全地读写。
3. **独占访问**: 应确保没有其他代码或线程同时修改同一组寄存器，以避免竞态条件。

违反这些条件可能导致系统崩溃、数据损坏或不可预测的行为。

**Section sources**
- [src/lib.rs](file://src/lib.rs#L63-L69)

## 常见问题排查

### “CRU not initialized” 错误

#### 原因
此错误表示尝试在 CRU 驱动未正确初始化的情况下执行操作。这通常由以下原因引起：
1. **未调用 `init_cru`**: 在调用 `api` 模块中的任何函数前，忘记调用 `init_cru` 进行初始化。
2. **初始化失败**: `init_cru` 调用本身可能因某些原因失败（例如，重复初始化），导致全局状态未被正确设置。
3. **并发问题**: 在多核环境中，可能存在竞争条件，尽管 `Once` 和 `Mutex` 的使用旨在防止这种情况。

#### 解决方法
1. **检查初始化流程**: 确保在程序启动的早期阶段调用了 `init_cru`，并且传入了正确的 `CruConfig`。
2. **验证返回值**: 始终检查 `init_cru` 的返回值，处理可能的错误（如“CRU already initialized”）。
3. **确认配置正确**: 确保 `CruConfig` 中的 `base_address` 与目标硬件的实际 CRU 基地址完全一致。

**Section sources**
- [src/lib.rs](file://src/lib.rs#L167-L215)
- [src/lib.rs](file://src/lib.rs#L217-L270)

## 最小可运行代码

以下是一个完整的、可在 `no-std` 环境下编译和运行的最小示例，用于验证 `phytium-pi-cru` 驱动的集成是否成功。

```rust
#![no_std]
#![no_main]

use core::panic::PanicInfo;
use phytium_pi_cru::{init_cru, CruConfig, api, PeripheralId};

#[no_mangle]
pub extern "C" fn _start() -> ! {
    // 步骤1: 初始化 CRU
    let config = CruConfig {
        instance_id: 0,
        base_address: 0x2800_0000, // 请根据实际硬件调整
    };

    match init_cru(config) {
        Ok(()) => {
            // 步骤2: 成功初始化后，尝试复位一个外设
            match api::reset_peripheral(PeripheralId::Gpio0) {
                Ok(true) => {
                    // 如果到达这里，说明集成基本成功
                    loop {
                        // 成功指示：可通过 LED 或其他方式通知
                    }
                }
                _ => {
                    // 复位失败，进入错误循环
                    loop {
                        // 错误指示
                    }
                }
            }
        }
        Err(_) => {
            // 初始化失败，进入错误循环
            loop {
                // 错误指示
            }
        }
    }
}

#[panic_handler]
fn panic(_info: &PanicInfo) -> ! {
    loop {}
}
```

将此代码集成到您的项目中，并确保链接器脚本正确设置了 `_start` 符号。如果程序能够顺利执行到成功循环，则表明驱动集成成功。