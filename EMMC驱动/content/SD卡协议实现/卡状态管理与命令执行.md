# 卡状态管理与命令执行

<cite>
**Referenced Files in This Document**   
- [constants.rs](file://src/mci_host/constants.rs)
- [mod.rs](file://src/mci_host/sd/mod.rs)
- [mci_cmd.rs](file://src/mci/mci_cmd.rs)
- [status.rs](file://src/mci_host/sd/status.rs)
- [consts.rs](file://src/mci_host/sd/consts.rs)
</cite>

## 目录
1. [SD卡状态机模型](#sd卡状态机模型)
2. [应用命令（ACMD）执行机制](#应用命令acmd执行机制)
3. [状态查询与超时处理](#状态查询与超时处理)

## SD卡状态机模型

SD卡的状态机模型基于`MCIHostCurrentState`枚举实现，该枚举定义了卡在不同操作阶段的九种状态。状态跟踪机制通过解析卡返回的状态寄存器（R1响应）来确定当前所处的状态。

状态转换遵循SD协议规范，从卡插入到数据传输的完整流程如下：

1.  **Idle（空闲）**: 卡上电或复位后的初始状态。通过发送CMD0（GO_IDLE_STATE）进入此状态。
2.  **Ready（就绪）**: 卡已准备好接收命令。通过发送CMD0后，卡会自动从Idle状态转换到Ready状态。
3.  **Identification（识别）**: 卡进入识别模式，用于获取卡的CID等信息。通过发送CMD2（ALL_SEND_CID）进入此状态。
4.  **Stand-by（待机）**: 卡已被识别并分配了相对地址（RCA）。通过发送ACMD3（SEND_RELATIVE_ADDR）进入此状态。
5.  **Transfer（传输）**: 卡被选中，可以进行数据传输。通过发送CMD7（SELECT_CARD）进入此状态。
6.  **SendingData（发送数据）**: 卡正在向主机发送数据。当主机发送读命令（如CMD17）时，卡进入此状态。
7.  **ReceiveData（接收数据）**: 卡正在从主机接收数据。当主机发送写命令（如CMD24）时，卡进入此状态。
8.  **Programming（编程）**: 卡正在执行写入、擦除等编程操作。在数据传输完成后，卡会进入此状态进行内部编程。
9.  **Disconnect（断开连接）**: 卡已断开连接。此状态用于表示卡的连接状态。

状态转换的核心逻辑在`SdCard.card_status_send`方法中实现，该方法通过发送CMD13（SEND_STATUS）查询卡的当前状态，并根据`MCIHostCurrentState::current_state`函数的解析结果判断卡是否处于可进行数据传输的就绪状态。

**Section sources**
- [constants.rs](file://src/mci_host/constants.rs#L129-L154)
- [mod.rs](file://src/mci_host/sd/mod.rs#L1391-L1392)

## 应用命令（ACMD）执行机制

应用命令（ACMD）是SD卡特有的命令，必须在普通命令（CMD）之前发送CMD55（APPLICATION_COMMAND）作为前缀。该机制的执行流程如下：

1.  **发送前置命令**: 在发送任何ACMD之前，必须先调用`application_cmd_send`方法。该方法内部会发送CMD55，并将卡的相对地址（RCA）作为参数。
2.  **发送应用命令**: 前置命令成功后，即可发送目标ACMD。

关键应用命令的使用场景和参数设置如下：

-   **ACMD6（切换总线宽度）**: 用于设置SD卡的数据总线宽度。在`SdCard.data_bus_width_set`方法中调用。参数设置为`0`表示1位模式，`2`表示4位模式。此命令通常在初始化流程中，读取SCR寄存器确认卡支持4位宽度后执行。
-   **ACMD13（获取卡状态）**: 用于读取SD状态寄存器（SD Status Register）。在`SdCard.status_read`方法中调用。该命令会触发一次数据传输，主机接收64位的SD状态信息，并通过`decode_status`方法解析，获取卡的总线宽度、速度等级、UHS等级等详细信息。
-   **ACMD41（操作条件）**: 用于SD卡的初始化和电压协商。在`SdCard.application_opration_condition_send`方法中调用。参数（OCR寄存器）用于指示主机支持的电压范围和卡容量类型。该命令在循环中反复发送，直到卡的响应中`POWER_UP_BUSY_FLAG`被置位，表示卡已完成上电和初始化。

**Section sources**
- [mod.rs](file://src/mci_host/sd/mod.rs#L1600-L1640)
- [mod.rs](file://src/mci_host/sd/mod.rs#L1710-L1752)
- [mod.rs](file://src/mci_host/sd/mod.rs#L1750-L1787)
- [consts.rs](file://src/mci_host/sd/consts.rs#L30-L41)

## 状态查询与超时处理

系统实现了完善的状态查询与超时处理机制，以确保数据传输的可靠性和稳定性。

**状态查询机制**:
-   **卡忙状态轮询**: 在数据传输（读/写）前后，系统会调用`polling_card_status_busy`方法。该方法通过循环发送CMD13（SEND_STATUS）来查询卡的状态。它会检查响应中的`READY_FOR_DATA`标志位，并确保卡当前不处于`Programming`状态。只有当卡处于就绪状态时，才允许进行下一次数据传输。
-   **错误状态检查**: 在发送命令后，系统会检查响应中的`ALL_ERROR_FLAG`。如果任何错误标志被置位，则认为命令执行失败。

**超时处理机制**:
-   **轮询超时**: `polling_card_status_busy`方法接受一个`timeout_ms`参数，用于设置最大等待时间。在循环中，每次查询后会休眠125微秒以降低轮询频率，同时递减超时计数器。如果在超时时间内卡仍未就绪，则返回`CardStatusBusy`错误。
-   **初始化超时**: 在发送ACMD41进行初始化时，代码中使用了一个最大重试次数（`MCI_HOST_MAX_CMD_RETRIES`）和10毫秒的延迟。如果在多次尝试后卡仍未响应，会记录超时错误并返回。
-   **数据传输超时**: 对于数据传输操作，底层硬件驱动（如DMA或PIO）会设置数据超时寄存器（`DATA_TIMEOUT`），以防止数据传输无限期挂起。

这些机制共同确保了在卡处于忙状态或发生错误时，系统能够及时检测并进行相应的错误处理或重试，从而保障了整个SD卡驱动的健壮性。

**Section sources**
- [mod.rs](file://src/mci_host/sd/mod.rs#L547-L585)
- [mod.rs](file://src/mci_host/sd/mod.rs#L1375-L1405)
- [constants.rs](file://src/mci_host/constants.rs#L110-L127)