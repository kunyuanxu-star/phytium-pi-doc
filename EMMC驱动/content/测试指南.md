# 测试指南

<cite>
**本文档中引用的文件**  
- [README.md](file://README.md)
- [tests/test.rs](file://tests/test.rs)
- [bare-test.toml](file://bare-test.toml)
- [Cargo.toml](file://Cargo.toml)
</cite>

## 目录
1. [简介](#简介)
2. [运行测试套件](#运行测试套件)
3. [测试用例结构分析](#测试用例结构分析)
4. [裸机测试配置](#裸机测试配置)
5. [故障排除](#故障排除)

## 简介
本指南旨在为飞腾（Phytium）SD MMC驱动项目提供详细的测试说明。文档将解释如何运行测试、理解测试流程、配置测试环境，并提供故障排查建议。测试主要验证SD卡的初始化、读写功能以及驱动在不同模式下的行为。

## 运行测试套件

### 使用 cargo test 命令
本项目的测试套件使用 Rust 的 `cargo test` 命令来执行。根据 `README.md` 文件的说明，运行测试的基本命令如下：

```bash
cargo test --test test -- --show-output
```

该命令的各个部分解释如下：
- `cargo test`: Cargo 的内置命令，用于编译并运行项目中的测试。
- `--test test`: 指定要运行的测试二进制文件的名称。在 `Cargo.toml` 文件中，`[[test]]` 部分定义了名为 `test` 的测试，因此需要使用此参数来明确指定。
- `--`: 这个分隔符告诉 `cargo test`，其后的所有参数都应传递给测试二进制文件本身，而不是传递给 `cargo` 命令。
- `--show-output`: 这是传递给测试二进制文件的关键参数。由于测试运行在裸机（bare-metal）环境中，它会通过 `log` 宏输出大量调试信息（如 `info!`, `error!`）。默认情况下，`cargo test` 会捕获这些输出。使用 `--show-output` 参数可以确保这些日志信息被打印到控制台，这对于观察测试执行流程和诊断问题至关重要。

### 切换至PIO模式
该项目默认使用DMA（直接内存访问）模式进行数据传输。如果需要测试PIO（Programmed Input/Output）模式，可以使用以下命令：

```bash
cargo test --test test --no-default-features --features pio -- --show-output 
```

此命令通过 `--no-default-features` 禁用了默认的 `dma` 特性，并通过 `--features pio` 启用了 `pio` 特性。这些特性在 `Cargo.toml` 文件中定义，用于条件编译不同的代码路径。

**Section sources**
- [README.md](file://README.md#L4-L17)
- [Cargo.toml](file://Cargo.toml#L28-L31)

## 测试用例结构分析

`tests/test.rs` 文件中的 `test_work` 函数是核心测试用例，它模拟了完整的SD卡操作流程。

### 测试流程概述
1.  **平台初始化**: 测试首先通过 `global_val().platform_info` 获取平台信息，并使用设备树（Device Tree）查找名为 `phytium,mci` 的兼容设备节点，以获取MCI控制器的寄存器基地址。
2.  **内存映射与初始化**: 使用 `iomap` 函数将物理寄存器地址映射到虚拟地址空间，并调用 `init_reg_base` 初始化寄存器基地址。这是后续所有操作的前提。
3.  **中断配置 (可选)**: 如果启用了 `irq` 特性，测试会注册一个中断处理函数 `fsdif_interrupt_handler` 来处理MCI控制器产生的中断。
4.  **SD卡初始化**: 创建一个 `SdCard` 实例，并调用其 `init` 方法。该方法会执行一系列SD卡协议规定的初始化命令（如CMD0, CMD8, ACMD41等），以识别和配置SD卡。
5.  **读写操作测试**: 初始化成功后，测试会执行以下步骤来验证数据完整性：
    *   **准备写入数据**: 创建一个 `Vec<u32>` 缓冲区，并用递增的数值填充。
    *   **执行写入**: 调用 `sdcard.write_blocks()` 方法，将缓冲区中的数据写入SD卡的指定块（`SD_START_BLOCK`）。
    *   **执行读取**: 调用 `sdcard.read_blocks()` 方法，从相同的块地址读取数据到一个新的缓冲区。
    *   **数据校验**: 使用 `assert_eq!` 宏逐项比较读取的数据与原始写入的数据，确保它们完全一致。如果数据不匹配，测试将失败。

### 模拟卡插入
在本测试中，“卡插入”的模拟是隐式的。代码通过 `polling_card_insert(SDStatus::Inserted)` 方法来检测卡的存在。只要设备树中配置了MCI控制器并且硬件连接正常，该方法就会返回成功，从而模拟了卡已插入的状态。测试的起点是假设SD卡已经物理插入并被系统检测到。

**Section sources**
- [tests/test.rs](file://tests/test.rs#L9-L217)

## 裸机测试配置

`bare-test.toml` 文件是为 `bare-test` 框架定义的配置文件，它指定了测试运行时的环境。

### 配置文件作用
该文件的主要作用是配置QEMU（Quick Emulator）的启动参数，以便在模拟环境中运行裸机测试。

### 配置项详解
```toml
[qemu]
graphic = false
args = ""
```
- `[qemu]`: 配置块，表明以下设置是针对QEMU模拟器的。
- `graphic = false`: 此选项禁用QEMU的图形化界面。测试在无头（headless）模式下运行，所有输出都通过串行控制台重定向到标准输出，这与 `--show-output` 参数配合，确保日志可以被正确捕获。
- `args = ""`: 此字段允许用户向QEMU传递额外的命令行参数。在当前配置中为空，意味着使用QEMU的默认参数。用户可以根据需要在此处添加参数，例如指定不同的机器类型或内存大小。

**Section sources**
- [bare-test.toml](file://bare-test.toml#L0-L3)

## 故障排除

当测试失败时，应遵循以下步骤进行排查。

### 解读测试失败信息
1.  **检查日志输出**: 首先，确保使用了 `--show-output` 参数。仔细阅读控制台输出的所有 `info!`, `warn!`, 和 `error!` 日志。日志会清晰地指出失败发生在哪个阶段。例如：
    *   `Sd Card Init Fail`: 表明SD卡初始化失败，问题可能出在硬件连接、供电或卡本身。
    *   `Error: read/write with parameter...`: 表明读写参数（如块大小）不被支持。
    *   `Polling card failed`: 表明驱动无法检测到SD卡。
2.  **定位断言失败**: 如果测试因 `assert_eq!` 失败而终止，这意味着读写操作虽然成功执行，但数据不一致。这通常指向DMA传输、缓存一致性或底层硬件驱动的严重问题。

### 常见问题与建议
-   **检查硬件连接**: 确保SD卡已正确插入插槽，并且连接稳定。松动的连接是导致初始化失败的常见原因。
-   **验证日志输出**: 如果没有看到任何日志，首先检查是否遗漏了 `--show-output` 参数。其次，确认 `bare-test` 框架和QEMU的串行端口配置是否正确。
-   **检查特性配置**: 确认运行的命令与期望的测试模式（DMA或PIO）相匹配。错误的特性组合可能导致未定义行为。
-   **查看QEMU输出**: 有时QEMU本身会输出错误信息（如设备未找到），这些信息对于诊断底层问题非常有帮助。

**Section sources**
- [README.md](file://README.md#L4-L17)
- [tests/test.rs](file://tests/test.rs#L9-L217)