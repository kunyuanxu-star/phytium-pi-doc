# 移植与定制

<cite>
**本文档引用的文件**  
- [lib.rs](file://src/lib.rs)
- [chip/mod.rs](file://src/chip/mod.rs)
- [bar_alloc.rs](file://src/bar_alloc.rs)
- [types/config/mod.rs](file://src/types/config/mod.rs)
- [types/config/card_bridge.rs](file://src/types/config/card_bridge.rs)
</cite>

## 目录
1. [简介](#简介)
2. [PcieGeneric 结构体作为参考实现](#pciegeneric-结构体作为参考实现)
3. [实现 rdif_pcie::Interface trait 以适配不同 PCIe 控制器](#实现-rdif_pcieinterface-trait-以适配不同-pcie-控制器)
4. [复用 DriverGeneric 的默认 open/close 行为](#复用-drivergeneric-的默认-openclose-行为)
5. [自定义 MMIO 读写方法以适配特定布局](#自定义-mmio-读写方法以适配特定布局)
6. [替换 SimpleBarAllocator 为自定义 BAR 分配策略](#替换-simplebarallocator-为自定义-bar-分配策略)
7. [日志系统集成现有内核日志设施](#日志系统集成现有内核日志设施)
8. [扩展 PciConfigSpace 支持 CardBusBridge](#扩展-pciconfigspace-支持-cardbusbridge)
9. [安全准则：使用 volatile 访问 MMIO 防止优化误删](#安全准则使用-volatile-访问-mmio-防止优化误删)
10. [封装高层 API 简化常见操作](#封装高层-api-简化常见操作)

## 简介
本文档旨在指导开发者如何将 `arceos_drivers/pcie` 库移植到新的硬件平台或进行功能定制。通过分析核心组件和接口设计，说明如何基于 `PcieGeneric` 实现跨平台兼容性，并提供关于内存映射 I/O（MMIO）、资源分配、日志集成及安全性方面的最佳实践。

## PcieGeneric 结构体作为参考实现

`PcieGeneric` 是一个通用的 PCIe 控制器实现，位于 `src/chip/mod.rs` 中，可用于大多数标准 PCIe 主机桥接场景。该结构体封装了 MMIO 基地址指针，并实现了 `rdif_pcie::Interface` 和 `DriverGeneric` trait，提供了基础的配置空间读写能力。

**中文(中文)**
- **mmio_base**: 指向 PCIe 配置空间 MMIO 映射起始地址的非空指针
- **new()**: 构造函数，接收 MMIO 基地址并初始化实例

此实现适用于 x86 或其他使用 ECAM（Enhanced Configuration Access Mechanism）规则访问 PCIe 设备的架构。

**Section sources**
- [chip/mod.rs](file://src/chip/mod.rs#L6-L15)

## 实现 rdif_pcie::Interface trait 以适配不同 PCIe 控制器

为了支持 SoC 专用 PCIe 控制器或其他非标准访问机制，用户需实现 `rdif_pcie::Interface` trait。该 trait 定义了两个核心方法：

- `read(&mut self, address: PciAddress, offset: u16) -> u32`
- `write(&mut self, address: PciAddress, offset: u16, value: u32)`

开发者可通过重写这两个方法，对接特定控制器的寄存器访问逻辑，例如通过专用 DMA 通道、间接索引端口等方式完成配置空间访问。

**Section sources**
- [chip/mod.rs](file://src/chip/mod.rs#L38-L51)

## 复用 DriverGeneric 的默认 open/close 行为

`DriverGeneric` trait 提供了设备驱动生命周期管理接口：

- `open(&mut self) -> Result<(), KError>`
- `close(&mut self) -> Result<(), KError>`

在 `PcieGeneric` 中，这两个方法均返回 `Ok(())`，表示无需额外初始化或清理动作。对于大多数嵌入式平台，若控制器上电即就绪，则可直接复用此默认行为，减少冗余代码。

**Section sources**
- [chip/mod.rs](file://src/chip/mod.rs#L28-L36)

## 自定义 MMIO 读写方法以适配特定布局

某些 SoC 可能采用非 ECAM 样式的 MMIO 布局，如分段式索引-数据寄存器或带 bank 切换的访问方式。此时应重写 `read` 和 `write` 方法，例如：

```rust
impl Interface for MyCustomPcieController {
    fn read(&mut self, addr: PciAddress, offset: u16) -> u32 {
        // 写入索引寄存器
        self.index_reg.write((addr.bus() << 16) | (addr.device() << 11) | ...);
        // 从数据寄存器读取
        self.data_reg.read()
    }

    fn write(&mut self, addr: PciAddress, offset: u16, value: u32) {
        self.index_reg.write(...);
        self.data_reg.write(value);
    }
}
```

此类实现允许完全控制底层访问时序与编码方式。

**Section sources**
- [chip/mod.rs](file://src/chip/mod.rs#L38-L51)

## 替换 SimpleBarAllocator 为自定义 BAR 分配策略

当前库通过 `SimpleBarAllocator` 提供基本的 BAR 地址分配功能，定义于 `rdif_pcie` crate。若需更复杂的分配逻辑（如对齐要求、区域保留、动态映射等），可实现 `BarAllocator` trait 并注入至 `PcieController`。

推荐使用 `RefCell<Rc<dyn BarAllocator>>` 类型持有分配器，以便在运行时动态切换策略或共享状态。

示例结构：
```rust
struct MyBarAllocator {
    allocated_ranges: Vec<(u64, u64)>,
}

impl BarAllocator for MyBarAllocator { ... }
```

然后在控制器初始化时传入：
```rust
let allocator: Rc<RefCell<dyn BarAllocator>> = Rc::new(RefCell::new(MyBarAllocator::new()));
let controller = PcieController::new(interface, allocator);
```

**Section sources**
- [bar_alloc.rs](file://src/bar_alloc.rs#L1-L2)

## 日志系统集成现有内核日志设施

本项目通过 `log` crate 提供全局日志宏支持（如 `info!`, `error!`）。开发者应在目标内核中实现 `log::Log` trait 并调用 `log::set_logger()` 注册具体日志后端。

例如，在内核启动阶段绑定打印函数：
```rust
struct KernelLogger;

impl log::Log for KernelLogger {
    fn enabled(&self, _: &Metadata) -> bool { true }
    fn log(&self, record: &Record) {
        println!("{}", record.args());
    }
    fn flush(&self) {}
}

static LOGGER: KernelLogger = KernelLogger;

log::set_logger(&LOGGER).unwrap();
log::set_max_level(LevelFilter::Info);
```

这样即可在 PCIe 驱动中使用 `info!("Found device: {:?}", dev);` 输出调试信息。

**Section sources**
- [lib.rs](file://src/lib.rs#L6)
- [test.rs](file://tests/test.rs#L15)

## 扩展 PciConfigSpace 支持 CardBusBridge

目前 `PciConfigSpace` 枚举已包含 `CardBusBridge` 变体，其实现位于 `src/types/config/card_bridge.rs`。尽管当前可能未完全启用或标记为待办（todo!），但结构上已具备支持能力。

通过实现其专属字段解析逻辑（如卡总线控制寄存器、中断路由表等），可完整启用 CardBus 功能。建议参考 PCI-to-CardBus Bridge Specification 文档完善字段定义与访问方法。

**Section sources**
- [card_bridge.rs](file://src/types/config/card_bridge.rs#L1-L23)
- [mod.rs](file://src/types/config/mod.rs#L1-L132)

## 安全准则：使用 volatile 访问 MMIO 防止优化误删

所有 MMIO 访问必须使用 `read_volatile` 和 `write_volatile`，确保编译器不会因“无副作用”假设而删除关键 I/O 操作。普通读写在优化构建中可能导致设备配置失败或状态丢失。

在 `PcieGeneric` 的实现中已正确使用：
```rust
unsafe { ptr.as_ptr().read_volatile() }
unsafe { ptr.as_ptr().write_volatile(value) }
```

这是保证硬件交互可靠性的强制要求，任何自定义实现都不得省略 `volatile` 关键字。

**Section sources**
- [chip/mod.rs](file://src/chip/mod.rs#L45-L51)

## 封装高层 API 简化常见操作

建议在基础枚举功能之上封装常用查询 API，例如：

```rust
fn find_devices_by_class_code(controller: &PcieController, base: u8, sub: u8) -> Vec<PciDevice>;
fn enable_memory_space(device: &mut PciDevice);
fn map_bar_region(device: &PciDevice, bar_index: usize) -> MappedRegion;
```

这些高层接口可显著降低应用层开发复杂度，提升代码可维护性。例如实现“查找所有显卡设备”：
```rust
let gpus = find_devices_by_class_code(&controller, 0x03, 0x00); // VGA 兼容控制器
for mut gpu in gpus {
    gpu.update_command(|cmd| cmd | CommandRegister::MEMORY_SPACE);
}
```

**Section sources**
- [types/config/mod.rs](file://src/types/config/mod.rs#L1-L132)
- [lib.rs](file://src/lib.rs#L1-L23)