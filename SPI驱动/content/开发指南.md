# 开发指南

<cite>
**本文档引用文件**  
- [lib.rs](file://src/lib.rs)
- [Cargo.toml](file://Cargo.toml)
</cite>

## 目录
1. [简介](#简介)
2. [项目结构说明](#项目结构说明)
3. [核心特性解析](#核心特性解析)
4. [构建与编译步骤](#构建与编译步骤)
5. [开发路线图建议](#开发路线图建议)
6. [贡献指南](#贡献指南)
7. [嵌入式环境下的安全编程](#嵌入式环境下的安全编程)

## 简介
本项目为飞腾派（Phytium Pi）平台提供SPI总线驱动支持，旨在实现稳定、高效、可移植的硬件通信能力。该驱动基于Rust语言编写，适用于无操作系统或裸机环境，遵循`no_std`原则，确保在资源受限的嵌入式系统中可靠运行。

## 项目结构说明
项目采用标准Rust crate结构组织代码：

```
.
├── src
│   └── lib.rs          # 驱动主模块，包含功能定义和待实现逻辑
└── Cargo.toml          # 构建配置文件，声明元信息与依赖项
```

- **src/**：源码目录，存放所有Rust实现文件。
- **src/lib.rs**：库入口文件，当前仅包含基本属性声明和TODO注释，尚未实现具体SPI功能。
- **Cargo.toml**：Rust项目的配置清单，定义包名、版本、作者、许可证及外部依赖。

**Section sources**
- [Cargo.toml](file://Cargo.toml#L1-L14)
- [lib.rs](file://src/lib.rs#L1-L3)

## 核心特性解析

### `#![no_std]` 属性的作用与意义
`#![no_std]` 是Rust中用于指示该crate不依赖标准库（`std`）的关键属性。在嵌入式开发场景下，目标设备通常缺乏完整的操作系统支持，无法使用如堆内存分配、文件系统、线程等高级功能。因此，必须使用精简的核心库（`core`）替代标准库。

其主要优势包括：
- **减少二进制体积**：避免链接庞大的标准库，生成更小的可执行文件。
- **提高确定性**：消除动态内存分配带来的不确定性行为，适合实时控制。
- **增强可移植性**：可在任何具备基础Rust运行环境的微控制器上运行。
- **安全性提升**：结合Rust的所有权机制，在无GC环境下仍能保证内存安全。

本项目明确启用 `no_std` 模式，并通过选择性启用第三方库的 `default-features = false` 来进一步裁剪依赖，确保最小化运行时开销。

**Section sources**
- [lib.rs](file://src/lib.rs#L1)
- [Cargo.toml](file://Cargo.toml#L10-L14)

## 构建与编译步骤

### 1. 安装Rust工具链
确保已安装支持嵌入式目标的Rust工具链：

```bash
# 安装rustup（若未安装）
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# 设置默认工具链为稳定版
rustup default stable

# 添加ARM Cortex-M目标支持（根据实际硬件调整）
rustup target add thumbv7m-none-eabi  # 示例：Cortex-M3
```

### 2. 配置Cargo以支持嵌入式构建
创建 `.cargo/config.toml` 文件以指定链接脚本和构建目标：

```toml
[build]
target = "thumbv7m-none-eabi"

[target.'cfg(all(target_arch = "arm", target_os = "none"))']
runner = "probe-rs run"
```

### 3. 构建项目
执行以下命令进行编译：

```bash
cargo build --release
```

输出的目标文件位于 `target/thumbv7m-none-eabi/release/phytium-pi-spi`，可进一步链接到固件镜像中。

### 4. 依赖说明
- **tock-registers**：提供类型安全的寄存器访问接口，用于操作SPI控制器硬件寄存器。
- **log**：轻量级日志输出，便于调试，需配合全局日志实现使用。
- **spin**：提供`SpinMutex`和`Once`等同步原语，适用于中断上下文中的临界区保护。

**Section sources**
- [Cargo.toml](file://Cargo.toml#L10-L14)

## 开发路线图建议

当前项目处于初始阶段，`lib.rs` 中存在明确TODO：“实现完整的SPI驱动功能”。以下是推荐的分阶段开发路径：

### 第一阶段：SPI寄存器模型定义
- 分析飞腾派SPI控制器的技术手册，确定关键寄存器地址与位域布局。
- 使用 `tock-registers` 宏定义寄存器结构体，确保类型安全访问。
- 实现基础读写操作封装。

### 第二阶段：SPI主机模式驱动实现
- 设计 `SpiMaster` 结构体，管理时钟配置、模式设置（CPOL/CPHA）、波特率等参数。
- 实现 `transfer(&mut self, words: &mut [u8])` 和 `write(&mut self, words: &[u8])` 方法。
- 支持DMA传输（如有硬件支持）以提升效率。

### 第三阶段：异步与中断支持
- 引入中断处理机制，响应TX/RX完成事件。
- 可选支持 `async`/`.await` 模型（需引入Wakers或调度框架）。

### 第四阶段：测试与验证
- 编写单元测试模拟寄存器行为（利用 `mockall` 或条件编译）。
- 在真实硬件上连接SPI从设备（如Flash芯片、传感器）进行通信验证。
- 添加性能基准测试，评估吞吐量与延迟。

### 第五阶段：文档与发布
- 补全API文档注释，生成 `cargo doc`。
- 更新README说明用法示例。
- 发布至crates.io（如适用）或集成至ArceOS生态系统。

**Section sources**
- [lib.rs](file://src/lib.rs#L3)

## 贡献指南

欢迎社区开发者参与本项目开发。请遵守以下规范：

### 代码风格要求
- 遵循Rust官方格式化工具 `rustfmt` 默认规则。
- 使用 `clippy` 进行静态检查，禁用非必要lint。
- 命名规范：
  - 类型与模块名使用大驼峰（`CamelCase`）
  - 函数与变量使用蛇形命名（`snake_case`）
  - 常量全大写加下划线（`UPPER_SNAKE_CASE`）

### 提交规范
- 每次提交应聚焦单一功能或修复。
- 提交消息格式：`<type>: <description>`
  - 类型可选：`feat`（新功能）、`fix`（修复）、`docs`（文档）、`refactor`（重构）、`chore`（维护）
  - 示例：`feat(spi): implement basic transfer function`

### 审查流程
- 所有变更须通过Pull Request提交。
- 至少一名核心成员审查并批准后方可合并。
- CI流水线需通过：
  - `cargo fmt --check`
  - `cargo clippy --target thumbv7m-none-eabi -- -D warnings`
  - `cargo test`

## 嵌入式环境下的安全编程

在资源受限且直接操控硬件的环境中，安全编程至关重要。本项目强调以下几点：

- **禁止动态内存分配**：避免使用 `Vec`、`String` 等堆类型；优先使用栈数组或静态缓冲区。
- **中断安全**：临界区使用 `spin::Mutex` 保护共享状态，防止竞态条件。
- **边界检查**：对所有输入数据进行有效性验证，防止缓冲区溢出。
- **错误传播**：使用 `Result<T, E>` 明确表达可能失败的操作，不得忽略返回值。
- **资源释放**：确保外设在不再使用时正确关闭（Drop trait实现）。
- **死锁预防**：避免嵌套锁获取，保持锁粒度最小化。

通过严格遵守上述原则，结合Rust语言本身的内存安全保证，可显著降低嵌入式系统中常见的漏洞风险。