# 快速入门

<cite>
**本文档中引用的文件**
- [README.md](file://igb/README.md)
- [lib.rs](file://igb/src/lib.rs)
- [osal.rs](file://igb/src/osal.rs)
- [ring/mod.rs](file://igb/src/ring/mod.rs)
- [ring/tx.rs](file://igb/src/ring/tx.rs)
- [ring/rx.rs](file://igb/src/ring/rx.rs)
- [mac.rs](file://igb/src/mac.rs)
- [phy.rs](file://igb/src/phy.rs)
- [descriptor.rs](file://igb/src/descriptor.rs)
- [err.rs](file://igb/src/err.rs)
- [Cargo.toml](file://igb/Cargo.toml)
- [bare-test.toml](file://igb/bare-test.toml)
- [test.rs](file://igb/tests/test.rs)
</cite>

## 目录
1. [环境准备](#环境准备)
2. [依赖项添加](#依赖项添加)
3. [驱动实例化与设备初始化](#驱动实例化与设备初始化)
4. [收发环创建](#收发环创建)
5. [数据包发送](#数据包发送)
6. [数据包接收](#数据包接收)
7. [完整示例程序框架](#完整示例程序框架)
8. [测试套件运行](#测试套件运行)

## 环境准备

在开始集成Intel IGB驱动之前，需要确保开发环境已正确配置。本驱动基于Rust语言开发，因此必须安装Rust工具链。建议使用`rustup`来管理Rust版本和组件。

首先，确保已安装最新稳定版的Rust编译器：
```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

由于该驱动为无标准库（no_std）环境设计，需添加对目标平台的支持。根据项目需求，可能需要安装特定的目标三元组，例如用于嵌入式系统的`thumbv7m-none-eabi`或用于其他架构的相应目标。

此外，项目根目录下的`rust-toolchain.toml`文件指定了推荐的Rust版本和组件，确保使用正确的编译器版本以避免兼容性问题。

**Section sources**
- [rust-toolchain.toml](file://rust-toolchain.toml)

## 依赖项添加

要在您的项目中使用此Intel IGB驱动，需要将其作为依赖项添加到`Cargo.toml`文件中。驱动的核心功能依赖于`dma-api`等关键crate，这些依赖已在驱动自身的`Cargo.toml`中声明。

在您的项目`Cargo.toml`中添加以下依赖：

```toml
[dependencies]
eth-igb = { path = "path/to/ethernet-intel/igb" }
dma-api = "0.5"
log = "0.4"
futures = "0.3"
```

其中，`eth-igb`是本驱动的主crate，提供了所有网络接口功能；`dma-api`用于管理DMA内存分配，这是实现零拷贝数据传输的基础；`log`用于日志输出，便于调试；`futures`支持异步操作。

注意：实际路径应根据您的项目结构进行调整。如果通过crates.io发布，可直接指定版本号而非本地路径。

**Section sources**
- [Cargo.toml](file://igb/Cargo.toml)

## 驱动实例化与设备初始化

驱动的使用始于`Igb`结构体的实例化。`Igb::new`函数接受一个指向设备I/O基地址的非空指针，并返回一个`Igb`实例或错误。此步骤完成了驱动与硬件的初步绑定。

在调用`Igb::new`后，必须实现`Kernel` trait以满足OSAL（操作系统抽象层）的需求。`Kernel` trait仅包含一个`sleep`方法，用于在等待硬件状态变化时进行延迟。用户需提供具体的睡眠实现，通常会调用底层操作系统的延时函数。

完成实例化后，调用`open()`方法启动设备。该方法执行一系列硬件初始化操作，包括重置MAC控制器、配置PHY物理层、启用中断和收发单元。此过程确保了网卡处于可操作状态，并建立了与网络的物理连接。

```rust
struct KernelImpl;

impl_trait! {
    impl Kernel for KernelImpl {
        fn sleep(duration: Duration) {
            your_os::spin_delay(duration);
        }
    }
}

let mut igb = Igb::new(iobase)?;
igb.open()?;
```

上述代码展示了如何实现`Kernel` trait并初始化驱动。`your_os::spin_delay`应替换为实际操作系统提供的延时函数。

**Section sources**
- [lib.rs](file://igb/src/lib.rs#L1-L178)
- [osal.rs](file://igb/src/osal.rs#L0-L25)
- [mac.rs](file://igb/src/mac.rs#L0-L692)
- [phy.rs](file://igb/src/phy.rs#L0-L342)

## 收发环创建

为了高效地进行数据包的发送和接收，驱动使用了环形缓冲区（Ring Buffer）机制。调用`new_ring()`方法可以创建一对发送和接收环（TxRing和RxRing）。这些环形缓冲区是DMA分配的内存区域，允许网卡直接访问，从而实现零拷贝的数据传输。

环形缓冲区的大小默认为256个描述符，可在`ring/mod.rs`中通过`DEFAULT_RING_SIZE`常量进行配置。每个描述符指向一个数据缓冲区，用于存放待发送或已接收的数据包。

创建环形缓冲区是数据通路建立的关键步骤。发送环负责将数据包从主机内存传输到网络，而接收环则用于存储从网络接收到的数据包。两者协同工作，构成了完整的双向通信链路。

```rust
let (tx_ring, rx_ring) = igb.new_ring()?;
```

此代码行创建了收发环，后续的数据包操作都将基于这两个环进行。

**Section sources**
- [lib.rs](file://igb/src/lib.rs#L1-L178)
- [ring/mod.rs](file://igb/src/ring/mod.rs#L0-L164)

## 数据包发送

数据包发送流程涉及`Request`和`TxRing`两个核心组件。首先，使用`Request::new_tx`创建一个发送请求，传入要发送的数据缓冲区（`Vec<u8>`）。该请求内部利用`dma-api`将普通内存转换为DMA可访问的内存，并获取其总线地址。

随后，调用`TxRing::send`方法将请求提交给发送环。驱动会将数据包的信息填充到发送描述符中，并更新环形缓冲区的尾部指针，通知硬件有新的数据包待发送。硬件完成发送后，会设置描述符的“Descriptor Done”位，表示该描述符可用。

```rust
let data = vec![0u8; 1500];
let request = Request::new_tx(data);
tx_ring.send(request)?;
```

此过程之所以需要DMA分配的内存，是因为网卡的DMA引擎需要直接访问物理内存来读取数据包内容。普通的虚拟内存地址对网卡不可见，因此必须使用经过DMA映射的物理连续内存区域。

**Section sources**
- [lib.rs](file://igb/src/lib.rs#L1-L178)
- [ring/tx.rs](file://igb/src/ring/tx.rs#L0-L194)

## 数据包接收

数据包接收流程与发送类似，但方向相反。首先，为接收环准备一个足够大的缓冲区（大小由`rx_ring.packet_size()`决定），并使用`Request::new_rx`创建接收请求。

然后，调用`submit`方法将请求提交给接收环。这会将空的描述符放入环中，等待硬件填充接收到的数据。当有数据包到达时，硬件会将数据写入指定的缓冲区，并更新描述符的状态。

通过调用`next_pkt()`方法，可以从接收环中获取一个`RxPacket`。如果返回`Some(packet)`，则表示成功接收到一个数据包。`RxPacket`实现了`Deref`，可以直接像切片一样访问其数据。处理完数据包后，应调用`re_submit`方法将其重新提交回接收环，以便循环使用缓冲区。

```rust
let buff = vec![0u8; rx_ring.packet_size()];
let request = Request::new_rx(buff);
rx_ring.submit(request)?;

if let Some(packet) = rx_ring.next_pkt() {
    println!("Received packet: {} bytes", packet.len());
}
```

**Section sources**
- [lib.rs](file://igb/src/lib.rs#L1-L178)
- [ring/rx.rs](file://igb/src/ring/rx.rs#L0-L249)

## 完整示例程序框架

以下是一个最小化的、可运行的示例程序框架，整合了上述所有步骤：

```rust
#![no_std]
#![no_main]

use core::time::Duration;
use eth_igb::{Igb, Request};

// 实现 OSAL 所需的 Kernel trait
struct KernelImpl;
impl_trait! {
    impl Kernel for KernelImpl {
        fn sleep(duration: Duration) {
            // 替换为实际的系统延时函数
            spin_on::spin_for(duration);
        }
    }
}

#[no_mangle]
pub extern "C" fn main(iobase: *mut u8) -> ! {
    // 1. 创建驱动实例
    let iobase = match NonNull::new(iobase) {
        Some(addr) => addr,
        None => panic!("Invalid IO base address"),
    };
    let mut igb = Igb::new(iobase).expect("Failed to create Igb instance");

    // 2. 打开设备
    igb.open().expect("Failed to open device");

    // 3. 创建收发环
    let (mut tx_ring, mut rx_ring) = igb.new_ring().expect("Failed to create rings");

    // 4. 发送一个简单的数据包
    let send_data = vec![0x48, 0x65, 0x6C, 0x6C, 0x6F]; // "Hello"
    let send_request = Request::new_tx(send_data);
    tx_ring.send(send_request).expect("Failed to send packet");

    // 5. 接收数据包
    let recv_buffer = vec![0u8; rx_ring.packet_size()];
    let recv_request = Request::new_rx(recv_buffer);
    rx_ring.submit(recv_request).expect("Failed to submit receive request");

    loop {
        if let Some(packet) = rx_ring.next_pkt() {
            // 处理接收到的数据包
            defmt::println!("Received: {} bytes", packet.len());
            // 将缓冲区重新提交以供再次使用
            packet.re_submit().expect("Failed to re-submit buffer");
        }
        // 主循环中可加入其他逻辑
    }
}
```

**Section sources**
- [README.md](file://igb/README.md#L0-L93)
- [lib.rs](file://igb/src/lib.rs#L1-L178)
- [osal.rs](file://igb/src/osal.rs#L0-L25)

## 测试套件运行

本项目包含一个综合的测试套件，位于`igb/tests/test.rs`。该测试使用`bare-test`框架，可以在模拟环境或真实硬件上验证驱动行为。

要运行所有测试，请执行：
```bash
cargo test --test test -- tests --show-output
```

若要在U-Boot开发板上进行测试，可添加`--uboot`标志：
```bash
cargo test --test test -- tests --show-output --uboot
```

`bare-test.toml`文件是测试框架的配置文件，定义了QEMU仿真环境的参数。它指定了机器类型（virt）、CPU型号（cortex-a53）以及额外的QEMU参数，特别是`-device igb,netdev=net0`，这会在虚拟机中创建一个Intel IGB网卡设备，使驱动能够在接近真实的环境中进行测试。

此配置对于验证驱动在目标平台上的功能至关重要，因为它模拟了驱动将要运行的实际硬件环境。

**Section sources**
- [test.rs](file://igb/tests/test.rs#L0-L421)
- [bare-test.toml](file://igb/bare-test.toml#L0-L5)